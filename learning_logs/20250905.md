# collections, Class
## python 대표 collection 종류
### 1. list
    여러 값을 저장할 때 가장 많이 사용. 자료형이 서로 다르더라도 하나의 리스트에 저장 가능.
    하나의 배열(파이썬에서 리스트와 비슷한 개념)에 동일한 조료형만을 저장할 수 있는 C, Java에 비해
    pyton이 가지는 장점 중 하나(근데 JS는 또 다양한 자료형이 배열에 저장되긴 합니다).
    
    slicing 
    ex) li = [4, 5, 6, 7, 8, 9, 0]
            print(li3[0:4:2])   0번지부터 4번지 앞 까지, 2씩 증가시키면서 출력
            결과값 : [4, 6]
    .append() - 항상 마지막 인덱스에 element를 추가
    .insert(위치, 값) - 정해진 위치(인덱스)에 해당 값을 추가
        ex) scores.insert(0, 90)    0번지에 90을 추가
    .pop() - 기존 요소를 삭제할 때
        ex) print(scores.pop(0))     0번지 값 90이 삭제되고 콘솔에 출력
### 2. tuple
    저장된 값을 변경할 수 없는 list라고 생각하시면 됩니다. 순서는 있기 때문에 index 넘버와 slicing은 가능하지만
       저장된 값 이외에는 추가 / 수정 / 삭제가 불가능
   생성시 - 3가지 방법 :  tu = (1,2,3) / tuple((4,5,6)) / 7,8,9
### 3. set
    수학의 집합 개념
    생성 방법 : set = {1,2,3} / set({1,2,3})
    비어있는 set을 생성했을 경우 dictionary 자료형으로 생성됩니다.
### 4. dict
    Java에서의 Map / JS에서의 Object / JSON과 같은 형식입니다.
```python
dict1 = {
'이름' : '김일',
'나이' : 20,
}
for key in dict1:
    print(key)
    print(dict1[key])
# key들만 추출할 때
print(dict1.keys())      # 결과값 : dict_keys(['이름', '나이'])
```
    dictionary에서 같은 방식의 반복문을 확용하게 될 때, key가 빠져 나옵니다.
    딕셔너리명[key]로 작성해주셔야 value를 조회할 수 있습니다.
    삭제시에는 key를 알아야 합니다.
    ex) dict1.pop('나이')

## 클래스 정의 형식
class 클래스명(파스칼케이스로):
    본문
객체이름 = 클래스명()

클래스의 기본 구성

        객체를 만들어내는 클래스는 객체가 가져야 할 구성 요소를 지닙니다
        객체를 생성하기 위해서는 객체가 가져야 할 '값'과 '기능'을 지녀야 합니다.
    
        값 = 속성(attribute)
        기능 = 메서드(method)
        self 키워드
        인스턴스 변수에서 각각의 객체를 의미하기 위해서 self 키워드를 붙여줍니다.
        인스턴스 메서드에서의 첫 번째 매개 변수로 '항상' self를 추가해야 합니다.
아래는 예시 코드입니다.
```python
class Person:
    # 메서드 정의(함수가 클래스 내에 있으니까요)
    def set_info(self, name, age, tel, address):    # call2() / setter
        self.name = name
        self.age = age
        self.tel = tel
        self.address = address

    def show_info(self):                            # call1()
        print(f'이름: {self.name}')
        print(f'나이: {self.age}')
        print(f'연락처: {self.tel}')
        print(f'주소: {self.address}')

    def show_info2(self):
        return f'제 이름은 {self.name}이고, {self.age} 살입니다. \n 연락처는 {self.tel}인데, {self.address}에 살고 있습니다.'
```
지금 속성값에 대한 제한이 있지 않다면 빈 객체 만들어놓고 거기에 값 대입하는게 비효율적으로 느껴집니다.
아래는 생성자를 도입한 예시 코드입니다.
```python
class Candy2:
    # 생성자 정의
    def __init__(self, shape, color):
        self.shape = shape
        self.color = color

    def show_info(self):
        print(f'사탕의 모양은 {self.shape}이고, 색깔은 {self.color}입니다.')

# 객체 생성 방식에서의 차이가 있습니다.
satang2 = Candy2('정육면체', '흰색')
satang2.show_info()
```